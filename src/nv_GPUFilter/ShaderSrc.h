//
// ShaderSrc.h
// Generated by $Id: //sw/devtools/SDK/9.5/SDK/DEMOS/OpenGL/src/GPUFilter/ShaderSrc.h#1 $
//

#ifndef _H_SHADERSRC_
#define _H_SHADERSRC_

// CMYKBlit_fs.glsl
const char CMYKBlit_fs_src[] = 	"varying vec2 pixelPos;\n"
	"uniform samplerRECT chunk;\n"
	"uniform sampler3D k[8];\n"
	"void main()\n"
	"{\n"
	"vec4 c = texRECT(chunk, pixelPos);\n"
	"vec4 accum = 0;\n"
	"c.a *= 7;\n"
	"for(int i = 0;i < 8;i++)\n"
	"accum += max(0,1 - abs(i - c.a)) * texture3D(k[i], c.rgb);\n"
	"gl_FragColor = vec4(accum.gba, 1);\n"
	"}\n"
;
// GrayBlit_fs.glsl
const char GrayBlit_fs_src[] = 	"varying vec2 pixelPos;\n"
	"uniform sampler2D grid;\n"
	"uniform samplerRECT chunk;\n"
	"uniform vec2 chunkPos;\n"
	"uniform bool hasAlpha;\n"
	"void main()\n"
	"{\n"
	"vec4 c = texRECT(chunk, pixelPos);\n"
	"if(hasAlpha)\n"
	"{\n"
	"vec3 gridc = vec3(0.9, 0.8, 1.0) * texture2D(grid, (pixelPos + chunkPos).xy/15).rgb;\n"
	"gl_FragColor = vec4(lerp(gridc, c.rrr, c.a), 1);\n"
	"}\n"
	"else\n"
	"gl_FragColor = c;\n"
	"}\n"
;
// LABBlit_fs.glsl
const char LABBlit_fs_src[] = 	"varying vec2 pixelPos;\n"
	"uniform sampler2D grid;\n"
	"uniform samplerRECT chunk;\n"
	"uniform vec2 chunkPos;\n"
	"uniform bool hasAlpha;\n"
	"const mat3 XYZConv =\n"
	"{\n"
	"vec3(3.240479,  -1.537150, -0.498535),\n"
	"vec3(-0.969256,	1.875992,  0.041556),\n"
	"vec3(0.055648,  -0.204043, 1.057311),\n"
	"};\n"
	"const vec3 XYZn = {0.950456, 1, 1.088754};\n"
	"const vec3 LabScale = {255.0f/500.0f,0,-255.0f/200.0f};\n"
	"void main()\n"
	"{\n"
	"vec4 lab = texRECT(chunk, pixelPos);\n"
	"float p = (lab.x * 100.0f + 16.0f) / 116.0f;\n"
	"vec3 xyz = XYZn * pow(p.xxx + (lab.yxz - 0.5)*LabScale, 3);\n"
	"if(hasAlpha)\n"
	"{\n"
	"vec3 gridc = texture2D(grid, (pixelPos + chunkPos).xy/15).rgb;\n"
	"gl_FragColor = vec4(lerp(gridc, clamp(pow(xyz*XYZConv, 1.0/2.2),0,1), lab.a), 1);\n"
	"}\n"
	"else\n"
	"gl_FragColor = vec4(pow(xyz*XYZConv, 1.0/2.2), 1);\n"
	"}\n"
;
// RGBBlit_fs.glsl
const char RGBBlit_fs_src[] = 	"varying vec2 pixelPos;\n"
	"uniform sampler2D grid;\n"
	"uniform samplerRECT chunk;\n"
	"uniform vec2 chunkPos;\n"
	"uniform bool hasAlpha;\n"
	"void main()\n"
	"{\n"
	"vec4 c = texRECT(chunk, pixelPos);\n"
	"if(hasAlpha)\n"
	"{\n"
	"vec3 gridc = texture2D(grid, (pixelPos + chunkPos).xy/15).rgb;\n"
	"gl_FragColor = vec4(lerp(gridc,c.rgb,c.a),1);\n"
	"}\n"
	"else\n"
	"gl_FragColor = c;\n"
	"}\n"
;
// Separable-Symmetric_fs.glsl
const char Separable_Symmetric_fs_src[] = 	"varying vec4 filterRange;\n"
	"uniform samplerRECT chunk;\n"
	"uniform half duoweights[KERNELSIZE];\n"
	"uniform vec4 offsets[KERNELSIZE];\n"
	"void main()\n"
	"{\n"
	"half4 accum = 0;\n"
	"for(int i = 0;i < KERNELSIZE;i++)\n"
	"{\n"
	"vec4 px = filterRange + offsets[i];\n"
	"accum += (texRECT(chunk, px.xy) + texRECT(chunk, px.zw)) * duoweights[i];\n"
	"}\n"
	"gl_FragColor = accum;\n"
	"}\n"
;
// Separable-Symmetric_vs.glsl
const char Separable_Symmetric_vs_src[] = 	"varying vec4 filterRange;\n"
	"uniform vec2 chunkPos;\n"
	"uniform vec2 filterSize;\n"
	"uniform float kernellen;\n"
	"void main()\n"
	"{\n"
	"gl_Position = gl_ProjectionMatrix * gl_Vertex;\n"
	"filterRange = vec4(1,1,-1,-1) * normalize(filterSize).xyxy * kernellen + (gl_Vertex.xy - chunkPos).xyxy;\n"
	"}\n"
;
// standard_fs.glsl
const char standard_fs_src[] = 	"varying vec2 pixelPos;\n"
	"uniform samplerRECT chunk;\n"
	"void main()\n"
	"{\n"
	"gl_FragColor = texRECT(chunk, pixelPos);\n"
	"}\n"
;
// standard_vs.glsl
const char standard_vs_src[] = 	"varying vec2 pixelPos;\n"
	"uniform vec2 chunkPos;\n"
	"void main()\n"
	"{\n"
	"gl_Position = gl_ProjectionMatrix * gl_Vertex;\n"
	"pixelPos = gl_Vertex.xy - chunkPos;\n"
	"}\n"
;

#endif /* _H_SHADERSRC_ */

//////////////////////////// eof //
