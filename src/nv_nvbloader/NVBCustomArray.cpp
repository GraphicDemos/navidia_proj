///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  Contains a custom array class.
 *  \file       NVBCustomArray.cpp
 *  \author     Pierre Terdiman
 *  \date       January, 15, 1999
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  Customized import/export array.
 *
 * Notes    : 
 *
 * CustomArray is a special array class especially designed for import/export goals, even if you can use it in many other ways.
 * Here are some basic usages and code examples:
 *
 * 1) Saving heterogeneous data to disk
 *
 *  Say you want to create a chunk-based file (e.g. a .3DS one). Such files may contain a chunk type (e.g. "FACE", i.e. a string) followed by
 *  chars or ints (e.g. vertex references) or floats (e.g. vertices). Saving such a file may be painful, and is usually done with an ugly list
 *  of putc/fputc. It also can be done with a single fwrite, but you must have stored your heterogeneous data beforehand, hence usually dealing
 *  with multiple pointers (e.g. a char*, an int*, a float*...) Well, that's ugly. With the CustomArray class you can solve this problem in an
 *  elegant way, with the following code:
 *
 *  \code
 *      CustomArray Array;              // constructor does all the painful stuff for you, destructor frees everything as well
 *
 *      // Store heterogeneous data in any order...
 *      Array.Store((char)1);
 *      Array.Store(10.0f);
 *      Array.Store((long)1);
 *      Array.Store("Test");
 *
 *      // ...and just save to disk
 *      Array.ExportToDisk("c:\\datas.bin");
 *  \endcode
 *
 *  Saved file is a linear binary file, made of following bytes:
 *  - 01
 *  - 10.0 in float
 *  - 00 00 00 01 (or 01 00 00 00, depends on your computer's little/big endian way of dealing with data)
 *  - the string "Test" (not ended by a null character)
 *
 *  And that's all. Very easy to use, and you don't have to know how many bytes you'll need. This is very useful when packing a file for example,
 *  as explained in the second example.
 *
 *
 * 2) Packing a buffer
 *
 *  Say you want to encode a buffer with an arithmetic coder, and your encoder gives you one packed byte at a time. You don't know the final packed size,
 *  but you don't need it if you use a CustomArray.
 *
 *  \code
 *      CustomArray Array;
 *      int EncodedByte;
 *
 *      do
 *      {
 *          EncodedByte = EncodeSymbol();                       // Get next packed byte or EOF (-1)
 *          if(EncodedByte!=EOF)    Array.Store(EncodedByte);   // Save packed byte
 *      }while(EncodedByte!=EOF);
 *
 *      Array.ExportToDisk("c:\\packed.bin");                   // Save packed file
 *  \endcode
 *
 *  You even can store bits in your CustomArray, with the StoreBit method. Call the StoreBit method 8 times, and a new byte will be added to the array.
 *  If you call StoreBit, say 6 times, and then call a standard Store method, 2 extra bits are automatically added to padd the address on a byte boundary.
 *
 *
 *  Now let's say you want your saved file to begin with the size of the packed data. (you could take the file's length, but imagine the packed data
 *  is part of a bigger file) As you don't know the final packed size before actually having packed it, this is painful: you must leave room for the
 *  final packed size at the start of the file, and fill it at the end of the process. If you save your file with some putc/fputc this is a real pain.
 *  The CustomArray class has a neat way of dealing with this problem: the PushAddress and PopAddressAndStore methods. Let's modify the example code:
 *
 *  \code
 *      CustomArray Array;
 *      int EncodedByte;
 *      long PackedSize = 0;
 *
 *      Array.Store((long)0).PushAddress();                     // Leave room for a long, save the address
 *
 *      do
 *      {
 *          EncodedByte = EncodeSymbol();                       // Get next packed byte or EOF (-1)
 *          if(EncodedByte!=EOF)    Array.Store(EncodedByte);   // Save packed byte
 *          if(EncodedByte!=EOF)    PackedSize++;               // Update packed size
 *      }while(EncodedByte!=EOF);
 *
 *      Array.PopAddressAndStore(PackedSize);                   // Store packed size where the PushAddress has been done.
 *
 *      Array.ExportToDisk("c:\\packed.bin");                   // Save packed file
 *  \endcode
 *
 *  Of course you can push more than one address (as many as you want):
 *
 *  \code
 *      Array.Store((long)0).PushAddress();                     // Push address 1 on the stack
 *      Array.Store((long)0).PushAddress();                     // Push address 2 on the stack
 *      Array.Store((long)0).PushAddress();                     // Push address 3 on the stack
 *      ...
 *      Array.Store((long)0).PushAddress();                     // Push address N on the stack
 *
 *      Array.PopAddressAndStore((long)1);                      // Pop address N and store value 1
 *      ...
 *      Array.PopAddressAndStore((long)N-2);                    // Pop address 3 and store value N-2
 *      Array.PopAddressAndStore((long)N-1);                    // Pop address 2 and store value N-1
 *      Array.PopAddressAndStore((long)N);                      // Pop address 1 and store value N
 *  \endcode
 *
 * 3) Creating a log file
 *
 *  The StoreASCII methods provide a very easy way to create log files (e.g. for debug purpose). Example:
 *
 *  \code
 *      Array.StoreASCII(10.0f);        // Store the string "10.0"
 *      Array.StoreASCII((long)1234);   // Store the string "1234"
 *      Array.StoreASCII(Boolean);      // Store the string "true" or "false", depends on the boolean value
 *  \endcode
 *
 *      Say "Score" is an udword whose value is 500:
 *  \code
 *      Array.StoreASCII("Your score is ").StoreASCII(Score).StoreASCII(".\n");     // Store the string "Your score is 500." (followed by a carriage return)
 *  \endcode
 *
 *      ...and so on...
 *
 *
 * 4) Getting the data back
 *
 *  This is easily done with the Collapse method, which creates a linear buffer filled with all stored data.
 *
 *
 * 5) Importing data
 *
 *  You can initialize a CustomArray with your own buffer, or even with a file:
 *
 *  \code
 *      CustomArray Array("c:\\data.bin");      // Read the whole file data.bin, fill the array with it
 *
 *      MyByte  = Array.GetByte();              // Get the first byte of the array, move the inner pointer one byte beyond
 *      MyFloat = Array.GetFloat();             // Get the next 4 bytes of the array, read as a float, move the inner pointer 4 bytes beyond
 *      ...
 *  \endcode
 *
 *
 *
 * History  :
 *  -   01/15/99: first version for Irion MAX Plug-In.
 *  -   02/04/99: ASCII support added.
 *  -   02/05/99: GetOffset(), Padd(), LinkTo(CustomArray* array) added.
 *  -   03/xx/99: Collapse() added, self-references added.
 *  -   03/xx/99: BOOL definition added in header if not defined yet, addies-stack mecanism added.
 *  -   04/xx/99: "push" renamed to "store", for a more coherent name since people were expecting a "pop" method to be used.............
 *  -   04/xx/99: BOOL handled as a long. Use bool (in lower case) for a real boolean value.
 *  -   05/xx/99: heap size is now 4Kb, and allocated ram is doubled for each new block. The more you eat, the more ram you're given.
 *  -   09/xx/99: bit-storage methods added (StoreBit, EndBits) for data-compression.
 *  -   10/29/99: bug fixed: mLastAddress was not initialized. Was crashing if the first thing done was a PushAddress. Well, a PushAddress should NOT
 *      be the first thing done anyway!
 *  -   11/04/99: address stack is now resizable.
 *  -   01/06/00: local memory manager and local error codes removed, CustomArray class added to IrionBasics.
 *  -   04/01/00: CustomArray included in NVB.
 *  -   08/27/00: little code lifting
 *
 * More notes:
 *  -   always keep in mind that an CustomArray eats CUSTOMARRAY_BLOCKSIZE bytes when initialized, even if you don't use it later.
 *      That's why you may use this class for very specific reasons, or even change this #define to match your own needs.
 *  -   I know I could've used templates.
 *  -   THIS IS NOT THREAD-SAFE.
 *
 *  \class      CustomArray
 *  \author     Pierre Terdiman
 *  \version    1.0
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Precompiled Header
#include "NVBCustomArray.h"
#include "NVBMemoryMacros.h"

#include <string>
extern udword      GetFileSize(const char* name);
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  Constructor.    The first block has a length of startsize bytes, and can be filled with an inputbuffer.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray::CustomArray(udword startsize, void* inputbuffer) 
  : mCollapsed(null), mAddresses(null), mNbPushedAddies(0), 
    mNbAllocatedAddies(0), mBitCount(0), mBitMask(0) 
{
    // Initialize first export block
    NewBlock(null, startsize);

    // Keep track of this first cell
    mInitCell = mCurrentCell;

    // Fill first block with provided buffer, if needed
    if(inputbuffer) memcpy(mCurrentCell->Item.Addy, inputbuffer, startsize);

    // Initialize mLastAddress so that it won't crash if the first thing you ever do is a PushAddress/PopAddressAndStore!!
    mLastAddress = mCurrentCell->Item.Addy;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  Constructor.    The file whose filename is given is loaded in the first block. Size of the block is the size of the file.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray::CustomArray(const char* filename) 
  : mCollapsed(null), mAddresses(null), mNbPushedAddies(0), 
    mNbAllocatedAddies(0), mBitCount(0), mBitMask(0)
{
    // Catch the file's size to initialize first block
    udword StartSize = GetFileSize(filename);
    if(!StartSize)  StartSize=CUSTOMARRAY_BLOCKSIZE;

    // Initialize first export block
    NewBlock(null, StartSize);

    // Keep track of this first cell
    mInitCell = mCurrentCell;

    // Fill first block with file data
    FILE* fp = fopen(filename, "rb");
    if(fp)
    {
        fread(mCurrentCell->Item.Addy, StartSize, 1, fp);
        fclose(fp);
    }

    // Initialize mLastAddress so that it won't crash if the first thing you ever do is a PushAddress/PopAddressAndStore!!
    mLastAddress = mCurrentCell->Item.Addy;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  Destructor. All blocks are released, as well as the possible collapsed array (whose address is then no more valid)
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray::~CustomArray()
{
    Empty();
}

CustomArray& CustomArray::Clean()
{
    Empty();

    // Initialize first export block
    NewBlock(null, CUSTOMARRAY_BLOCKSIZE);

    // Keep track of this first cell
    mInitCell = mCurrentCell;

    // Initialize mLastAddress so that it won't crash if the first thing you ever do is a PushAddress/PopAddressAndStore!!
    mLastAddress = mCurrentCell->Item.Addy;

    return *this;
}

CustomArray& CustomArray::Empty()
{
    // Free possible collapsed array
    if (mCollapsed)
    {
        delete [] (char*)mCollapsed;
        mCollapsed = null;
    }

    // Free possible adress list
    DELETEARRAY(mAddresses);

    // Free linked list
    CustomCell* CurCell = mInitCell;
    while(CurCell)
    {
        CustomCell* Cell = CurCell;
        CurCell = CurCell->NextCustomCell;
        DELETESINGLE(Cell);
    }
    return *this;
}





///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// MANAGEMENT METHODS
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to create and link a new block to previous ones.
 *  'size' is only used if previouscell is null (i.e. for the first cell).
 *  \param      previouscell    [in] the previous cell, or null if this is the first.
 *  \param      size            [in] number of bytes to allocate for the first cell.
 *  \return     true if success
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CustomArray::NewBlock(CustomCell* previouscell, udword size)
{
    // Create a new cell
    CustomCell* Cell = new CustomCell;
    CHECKALLOC(Cell);

    // If a previous cell exists, doubles the needed ram, else get default size
    Cell->Item.Max = previouscell ? previouscell->Item.Max*2 : size;

    // Get some bytes for this cell
    Cell->Item.Addy = (void*)new ubyte[Cell->Item.Max];
    CHECKALLOC(Cell->Item.Addy);
    Cell->Item.Size = 0;

    mCurrentCell = Cell;

    // Update linked list
    if(previouscell) previouscell->NextCustomCell = mCurrentCell;

    return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to check whether there's enough room in current block for expected datas, or not.
 *  A new block is created if there's no more space left in current block.
 *  \param      bytesneeded     [in] number of expected bytes
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::CheckArray(udword bytesneeded)
{
    udword ExpectedSize = mCurrentCell->Item.Size + bytesneeded;
    if(ExpectedSize > mCurrentCell->Item.Max)   NewBlock(mCurrentCell);
    // I assume there IS enough room in the new block for expected data. It should always be the case since 'bytesneeded' is not supposed to be larger than 8
    // (i.e. sizeof(double))
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to export an array to disk.
 *  \param      filename    [in] the destination file's name.
 *  \param      access      [in] a possible custom access, or null
 *  \return     true if success
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CustomArray::ExportToDisk(const char* filename, const char* access)
{
    FILE* fp = access ? fopen(filename, access) : fopen(filename, "wb");
    if(!fp) return false;
    bool Status = ExportToDisk(fp);
    fclose(fp);
    return Status;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to export an array to disk.
 *  \param      fp      [in] the file pointer.
 *  \return     true if success
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CustomArray::ExportToDisk(FILE* fp)
{
    // Fill possible remaining bits with 0
    EndBits();

    CustomCell* p = mInitCell;

    while(p->NextCustomCell)
    {
        // Save current cell
        if(!SaveCell(p, fp)) return false;
        // Go to next cell
        p = p->NextCustomCell;
    }
    // Save last cell
    if(!SaveCell(p, fp)) return false;

    return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to write a single cell to disk.
 *  \param      p       [in] current cell.
 *  \param      fp      [in] file pointer
 *  \return     true if success
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CustomArray::SaveCell(CustomCell* p, FILE* fp)
{
    udword BytesToWrite = p->Item.Size;
    if(!BytesToWrite) return true;
    if(fwrite(p->Item.Addy, 1, BytesToWrite, fp)!=BytesToWrite) return false;
    return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to get current number of bytes stored.
 *  \return     number of bytes stored
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
udword CustomArray::GetOffset()
{
    udword Offset = 0;
    CustomCell* p = mInitCell;

    while(p->NextCustomCell)
    {
        // Add offset from current cell
        Offset+=p->Item.Size;
        // Go to next cell
        p = p->NextCustomCell;
    }
    // Add offset from last cell
    Offset+=p->Item.Size;

    return Offset;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to padd offset on a 8 bytes boundary.
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Padd()
{
    // Fill possible remaining bits with 0
    EndBits();

    udword Offset = GetOffset();
    udword NbPadd = Offset - (Offset & 7);
    for(udword i=0;i<NbPadd;i++) Store((char)0);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to link 2 arrays.
 *  \param      array       [in] the array to link
 *  \return     Self-Reference
 *  \bug        OBSOLETE CODE
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::LinkTo(CustomArray* array)
{
    // ### THIS METHOD NEEDS RECODING & TESTING
/*
    CustomCell* p = mInitCell;
    char* Addy;
    udword i;

    while(p->NextCustomCell)
    {
        // Link current cell
        Addy = (char*)p->Item.Addy;
        for(i=0;i<p->Item.Size;i++) Store(*Addy++);

        // Go to next cell
        p = p->NextCustomCell;
    }
    // Link last cell
    Addy = (char*)p->Item.Addy;
    for(i=0;i<p->Item.Size;i++) Store(*Addy++);
*/
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to collapse a CustomArray into a single continuous buffer. This invalidates all pushed addies.
 *  If you provide your destination buffer original bytes are copied into it, then it's safe using them.
 *  If you don't, returned address is valid until the array's destructor is called. Beware of memory corruption...
 *  \param      userbuffer      [out] destination buffer (provided or not)
 *  \return     destination buffer
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void* CustomArray::Collapse(void* userbuffer)
{
    // Fill possible remaining bits with 0
    EndBits();

    char* Addy;
    CustomCell* p = mInitCell;

    if(!userbuffer)
    {
        if (mCollapsed)
        {
            delete [] (char*)mCollapsed;
            mCollapsed = null;
        }
        udword CurrentSize = GetOffset();
        mCollapsed = CurrentSize ? new ubyte[CurrentSize] : null;
        Addy = (char*)mCollapsed;
    }
    else
    {
        Addy = (char*)userbuffer;
    }

    char* AddyCopy = Addy;
    if(Addy)
    {
        while(p->NextCustomCell)
        {
            // Collapse current cell
            memcpy(Addy, p->Item.Addy, p->Item.Size);
            Addy+=p->Item.Size;

            // Go to next cell
            p = p->NextCustomCell;
        }
        // Collapse last cell
        memcpy(Addy, p->Item.Addy, p->Item.Size);
        Addy+=p->Item.Size;
        mNbPushedAddies=0;
    }
    return AddyCopy;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// STORE METHODS
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to prepare an access.
 *  \param      size        [in] expected number of bytes involved
 *  \return     storage address
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void* CustomArray::PrepareAccess(udword size)
{
    mLastAddress = GetAddress();
    mCurrentCell->Item.Size+=size;
    return mLastAddress;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a BOOL.
 *  \param      bo      [in] BOOL to store
 *  \return     Self-Reference
 *  \warning    BOOL actually is an int. Converted to long.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(BOOL bo)
{
    long b = (long)bo;

    // Fill possible remaining bits with 0
    EndBits().CheckArray(sizeof(long));

    long* Current = (long*)PrepareAccess(sizeof(long));
    *Current=b;
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a bool.
 *  \param      bo      [in] bool to store
 *  \return     Self-Reference
 *  \warning    Converted to char.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(bool bo)
{
    char b = bo ? 1 : 0;

    // Fill possible remaining bits with 0
    EndBits().CheckArray(sizeof(char));

    char* Current = (char*)PrepareAccess(sizeof(char));
    *Current=b;
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a char.
 *  \param      b       [in] char to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(char b)
{
    // Fill possible remaining bits with 0
    EndBits().CheckArray(sizeof(char));

    char* Current = (char*)PrepareAccess(sizeof(char));
    *Current=b;
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store an ubyte.
 *  \param      b       [in] ubyte to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(ubyte b)
{
    // Fill possible remaining bits with 0
    EndBits().CheckArray(sizeof(ubyte));

    ubyte* Current = (ubyte*)PrepareAccess(sizeof(ubyte));
    *Current=b;
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a short.
 *  \param      w       [in] short to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(short w)
{
    // Fill possible remaining bits with 0
    EndBits().CheckArray(sizeof(short));

    short* Current = (short*)PrepareAccess(sizeof(short));
    *Current=w;
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store an uword.
 *  \param      w       [in] uword to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(uword w)
{
    // Fill possible remaining bits with 0
    EndBits().CheckArray(sizeof(uword));

    uword* Current = (uword*)PrepareAccess(sizeof(uword));
    *Current=w;
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a long.
 *  \param      d       [in] long to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(long d)
{
    // Fill possible remaining bits with 0
    EndBits().CheckArray(sizeof(long));

    long* Current = (long*)PrepareAccess(sizeof(long));
    *Current=d;
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store an unsigned long.
 *  \param      d       [in] unsigned long to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(unsigned long d)
{
    // Fill possible remaining bits with 0
    EndBits().CheckArray(sizeof(unsigned long));

    unsigned long* Current = (unsigned long*)PrepareAccess(sizeof(unsigned long));
    *Current=d;
    return *this;
}

/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A method to store an int.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Input    :   d       = int to store.
// Output   :   -
// Return   :   Self-Reference
// Remark   :   -
CustomArray& CustomArray::Store(int d)
{
    // Fill possible remaining bits with 0
    EndBits().CheckArray(sizeof(int));

    char* CurrentAddy = (char*)mCurrentCell->Item.Addy;
    CurrentAddy+=mCurrentCell->Item.Size;

    int* Current = (int*)CurrentAddy;
    *Current=d;
    mLastAddress = (void*)Current;
    mCurrentCell->Item.Size+=sizeof(int);
    return *this;
}
*/

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store an unsigned int.
 *  \param      d       [in] unsigned int to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(unsigned int d)
{
    // Fill possible remaining bits with 0
    EndBits().CheckArray(sizeof(unsigned int));

    unsigned int* Current = (unsigned int*)PrepareAccess(sizeof(unsigned int));
    *Current=d;
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a float.
 *  \param      d       [in] float to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(float f)
{
    // Fill possible remaining bits with 0
    EndBits().CheckArray(sizeof(float));

    float* Current = (float*)PrepareAccess(sizeof(float));
    *Current=f;
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a double.
 *  \param      d       [in] double to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(double f)
{
    // Fill possible remaining bits with 0
    EndBits().CheckArray(sizeof(double));

    double* Current = (double*)PrepareAccess(sizeof(double));
    *Current=f;
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a string.
 *  \param      string      [in] the string to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(const char* string)
{
    // Fill possible remaining bits with 0
    EndBits();

    if(string)
    {
        for(udword i=0;i<strlen(string);i++)
        {
            Store((char)string[i]);
        }
    }
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a buffer. Only available in binary mode.
 *  \param      buffer      [in] the input buffer.
 *  \param      size        [in] the buffer size.
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(void* buffer, udword size)
{
    if(buffer)
    {
        // Fill possible remaining bits with 0
        EndBits();

        ubyte* p = (ubyte*)buffer;
        for(udword i=0;i<size;i++)
        {
            Store(p[i]);
        }
    }
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a CustomArray. Only available in binary mode.
 *  \param      array       [in] the input CustomArray
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Store(CustomArray* array)
{
    if(array)   Store(array->Collapse(), array->GetOffset());
    return *this;
}



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// STOREASCII METHODS
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store an ASCII code.
 *  \param      code        [in] input byte.
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCIICode(char code)
{
    // Fill possible remaining bits with 0
    EndBits().CheckArray(sizeof(char));

    char* Current = (char*)PrepareAccess(sizeof(char));
    *Current=code;
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a BOOL in ASCII.
 *  \param      bo      [in] the BOOL to store.
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(BOOL bo)
{
    char Text[256];
    sprintf(Text, "%d", (int)bo);
    StoreASCII((const char*)Text);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a bool in ASCII.
 *  \param      bo      [in] the bool to store.
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(bool bo)
{
    if(bo)  StoreASCII((const char*)"true");
    else    StoreASCII((const char*)"false");
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a char in ASCII.
 *  \param      b       [in] the char to store.
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(char b)
{
    char Text[256];
    sprintf(Text, "%d", b);
    StoreASCII((const char*)Text);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store an ubyte in ASCII.
 *  \param      b       [in] the ubyte to store.
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(ubyte b)
{
    char Text[256];
    sprintf(Text, "%u", b);
    StoreASCII((const char*)Text);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a short in ASCII.
 *  \param      w       [in] the short to store.
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(short w)
{
    char Text[256];
    sprintf(Text, "%d", w);
    StoreASCII((const char*)Text);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store an uword in ASCII.
 *  \param      w       [in] the uword to store.
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(uword w)
{
    char Text[256];
    sprintf(Text, "%u", w);
    StoreASCII((const char*)Text);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a long in ASCII.
 *  \param      d       [in] the long to store.
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(long d)
{
    char Text[256];
    sprintf(Text, "%d", (int)d);
    StoreASCII((const char*)Text);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store an unsigned long in ASCII.
 *  \param      d       [in] the unsigned long to store.
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(unsigned long d)
{
    char Text[256];
    sprintf(Text, "%u", (unsigned int)d);
    StoreASCII((const char*)Text);
    return *this;
}

/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A method to store an int in ASCII.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Input    :   d       = the int to store.
// Output   :   -
// Return   :   Self-Reference
// Remark   :   -
CustomArray& CustomArray::StoreASCII(int d)
{
    char Text[256];
    sprintf(Text, "%d", d);
    StoreASCII((const char*)Text);
    return *this;
}
*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store an unsigned int in ASCII.
 *  \param      d       [in] the unsigned int to store.
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(unsigned int d)
{
    char Text[256];
    sprintf(Text, "%u", d);
    StoreASCII((const char*)Text);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a float in ASCII.
 *  \param      f       [in] the float to store.
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(float f)
{
    char Text[256];
    sprintf(Text, "%f", f);
    StoreASCII((const char*)Text);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a double in ASCII.
 *  \param      f       [in] the double to store.
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(double f)
{
    char Text[256];
    sprintf(Text, "%f", f);
    StoreASCII((const char*)Text);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to store a string in ASCII.
 *  \param      string      [in] the string to store.
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::StoreASCII(const char* string)
{
    // Fill possible remaining bits with 0
    EndBits();

    if(string)
    {
        for(udword i=0;i<strlen(string);i++)
        {
            if(string[i]=='\n')
            {
                StoreASCIICode((char)0x0d);
                StoreASCIICode((char)0x0a);
            }
            else 
                StoreASCIICode((char)string[i]);
        }
    }
    return *this;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// BIT STORAGE METHODS
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
*   A method to padd bits on a byte.
*   \return     Self-Reference
*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::EndBits()
{
    while(mBitCount)    StoreBit(false);
    return *this;
}




///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// PUSH/POP ADDRESS METHODS
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to push current address into the address-stack for later processing.
 *  \return     true if success, else false
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
bool CustomArray::PushAddress()
{
    // Check available space and resize if needed.
    if((mNbPushedAddies+1)>mNbAllocatedAddies)
    {
        // Here we must resize. We get twnvb as much bytes as already allocated in order to minimize total #resizes.
        udword NewSize = mNbAllocatedAddies ? mNbAllocatedAddies * 2 : 1;

        // Create new buffer...
        void** Addresses = new void*[NewSize];
        if(!Addresses)  return false;

        // ...copy & release old one to new one if old one exists...
        if(mNbAllocatedAddies)
        {
            memcpy(Addresses, mAddresses, mNbAllocatedAddies * sizeof(void*));
            DELETEARRAY(mAddresses);
        }

        // ...and set new members.
        mAddresses          = Addresses;
        mNbAllocatedAddies  = NewSize;
    }

    // Save last address
    mAddresses[mNbPushedAddies++] = mLastAddress;
    return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to pop an address and store a BOOL where the poped address tells.
 *  \param      bo          [in] the BOOL to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(BOOL bo)
{
    if(mNbPushedAddies)
    {
        BOOL* Addy = (BOOL*)mAddresses[--mNbPushedAddies];
        *Addy=bo;
    }
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to pop an address and store a bool where the poped address tells.
 *  \param      bo          [in] the bool to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(bool bo)
{
    if(mNbPushedAddies)
    {
        char* Addy = (char*)mAddresses[--mNbPushedAddies];
        *Addy=(char)bo;
    }
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to pop an address and store a char where the poped address tells.
 *  \param      b           [in] the char to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(char b)
{
    if(mNbPushedAddies)
    {
        char* Addy = (char*)mAddresses[--mNbPushedAddies];
        *Addy=b;
    }
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to pop an address and store an ubyte where the poped address tells.
 *  \param      b           [in] the ubyte to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(ubyte b)
{
    if(mNbPushedAddies)
    {
        ubyte* Addy = (ubyte*)mAddresses[--mNbPushedAddies];
        *Addy=b;
    }
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to pop an address and store a short where the poped address tells.
 *  \param      w           [in] the short to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(short w)
{
    if(mNbPushedAddies)
    {
        short* Addy = (short*)mAddresses[--mNbPushedAddies];
        *Addy=w;
    }
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to pop an address and store an uword where the poped address tells.
 *  \param      w           [in] the uword to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(uword w)
{
    if(mNbPushedAddies)
    {
        uword* Addy = (uword*)mAddresses[--mNbPushedAddies];
        *Addy=w;
    }
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to pop an address and store a long where the poped address tells.
 *  \param      d           [in] the long to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(long d)
{
    if(mNbPushedAddies)
    {
        long* Addy = (long*)mAddresses[--mNbPushedAddies];
        *Addy=d;
    }
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to pop an address and store an unsigned long where the poped address tells.
 *  \param      d           [in] the unsigned long to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(unsigned long d)
{
    if(mNbPushedAddies)
    {
        unsigned long* Addy = (unsigned long*)mAddresses[--mNbPushedAddies];
        *Addy=d;
    }
    return *this;
}
/*
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// A method to pop an address and store an int where the poped address tells.
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Input    :   d       = the int to store
// Output   :   -
// Return   :   Self-Reference
// Remark   :   -
CustomArray& CustomArray::PopAddressAndStore(int d)
{
    if(mNbPushedAddies)
    {
        int* Addy = (int*)mAddresses[--mNbPushedAddies];
        *Addy=d;
    }
    return *this;
}
*/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to pop an address and store an unsigned int where the poped address tells.
 *  \param      d           [in] the unsigned int to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(unsigned int d)
{
    if(mNbPushedAddies)
    {
        unsigned int* Addy = (unsigned int*)mAddresses[--mNbPushedAddies];
        *Addy=d;
    }
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to pop an address and store a float where the poped address tells.
 *  \param      f           [in] the float to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(float f)
{
    if(mNbPushedAddies)
    {
        float* Addy = (float*)mAddresses[--mNbPushedAddies];
        *Addy=f;
    }
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to pop an address and store a double where the poped address tells.
 *  \param      f           [in] the double to store
 *  \return     Self-Reference
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::PopAddressAndStore(double f)
{
    if(mNbPushedAddies)
    {
        double* Addy = (double*)mAddresses[--mNbPushedAddies];
        *Addy=f;
    }
    return *this;
}


///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// READ METHODS
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    inline void swap_endian2(void *val)
    {
#ifdef MACOS
        unsigned short *ival = (unsigned short *)val;
  
        *ival = ((*ival >>  8) & 0x000000ff) |
                ((*ival <<  8) & 0x0000ff00);
#endif
    }

    inline void swap_endian4(void *val)
    {
#ifdef MACOS
        unsigned long *ival = (unsigned long *)val;
  
        *ival = ((*ival >> 24) & 0x000000ff) |
                ((*ival >>  8) & 0x0000ff00) |
                ((*ival <<  8) & 0x00ff0000) |
                ((*ival << 24) & 0xff000000);
#endif
    }
    
ubyte CustomArray::GetByte()    {   ubyte* Current = (ubyte*)PrepareAccess(sizeof(ubyte));      return *Current;    }
uword CustomArray::GetWord()    
{   
    uword* Current = (uword*)PrepareAccess(sizeof(uword));      
    swap_endian2(Current);
    return *Current;    
}

udword CustomArray::GetDword()  
{   
    udword* Current = (udword*)PrepareAccess(sizeof(udword));   
    swap_endian4(Current);
    return *Current;    
}

float CustomArray::GetFloat()   
{   
    float* Current = (float*)PrepareAccess(sizeof(float));      
    swap_endian4(Current);
    return *Current;    
}

ubyte* CustomArray::GetString()
{
    ubyte* StringAddress = (ubyte*)GetAddress();

    ubyte c;
    do{
        c = GetByte();
    }
    while(c);

    return StringAddress;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to set the current address within current block. Input offset can't be greater than current block's length.
 *  \param      offset      [in] the wanted offset within the block.
 *  \return     Self-Reference.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
CustomArray& CustomArray::Reset(udword offset)
{
    if(offset<mCurrentCell->Item.Max)
    {
        mCurrentCell->Item.Size = offset;
        ubyte* CurrentAddy = (ubyte*)mCurrentCell->Item.Addy;
        CurrentAddy+=mCurrentCell->Item.Size;
        mLastAddress = (void*)CurrentAddy;
    }
    return *this;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to find a given chunk in current buffer.
 *  \param      chunk       [in] chunk you're looking for.
 *  \return     address where the chunk was found, or null.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void* CustomArray::GetChunk(const char* chunk)
{
    char Data[5];
    char* Addy = (char*)mCurrentCell->Item.Addy;
    Data[4]=0;
    for(udword i=0;i<mCurrentCell->Item.Max-3;i++)
    {
        Data[0] = *(Addy+0);
        Data[1] = *(Addy+1);
        Data[2] = *(Addy+2);
        Data[3] = *(Addy+3);
        if(strcmp((const char*)Data, chunk)==0)
        {
            udword CorrectAddy = udword(Addy+4);
            udword CorrectOffset = CorrectAddy - udword(mCurrentCell->Item.Addy);
            mCurrentCell->Item.Size = CorrectOffset;
            return (void*)CorrectAddy;
        }
        Addy++;
    }
    return null;
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 *  A method to retrieve a number of bytes in a chunk.
 *  \param      size = chunk to retrieve
 *  \return     address where the data was found, or null.
 */
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void* CustomArray::GetData(udword size)
{
    udword ExpectedSize = mCurrentCell->Item.Size + size;
    if (ExpectedSize > mCurrentCell->Item.Max)
    {
        return NULL;
    }

    return (void *)CustomArray::PrepareAccess(size);
}
